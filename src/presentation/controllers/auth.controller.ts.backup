/**
 * üîê AUTH CONTROLLER - Authentification avec JWT et cookies
 *
 * Contr√¥leur d'authentification avec gestion des tokens et cookies
 * Support dev et production avec s√©curit√© renforc√©e
 */

import {
  BadRequestException,
  Body,
  Controller,
  Get,
  HttpCode,
  HttpStatus,
  Inject,
  Post,
  Req,
  Res,
  UnauthorizedException
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Req  /**
   * üç™ Configuration des cookies d'authentification
   */
  private setAuthCookies(
    response: Response,
    tokens: { accessToken: string; refreshToken: string },
    rememberMe?: boolean,
  ): void {
    // D√©tection de l'environnement
    const isProduction = this.configService.get('NODE_ENV') === 'production';
    
    // Configuration des cookies selon l'environnement
    const cookieOptions = {
      httpOnly: true,
      secure: isProduction, // HTTPS uniquement en production
      sameSite: (isProduction ? 'strict' : 'lax') as 'strict' | 'lax',
      domain: isProduction ? this.configService.get('COOKIE_DOMAIN') : undefined,
      path: '/',
    };om 'express';
import type { I18nService } from '../../application/ports/i18n.port';
import type { Logger } from '../../application/ports/logger.port';
import type { UserRepository } from '../../domain/repositories/user.repository';
import { Email } from '../../domain/value-objects/email.vo';
import { TOKENS } from '../../shared';
import {
  LoginResponse,
  RefreshTokenResponse
} from '../../shared/types/auth.types';

// DTOs pour la validation
interface LoginDto {
  email: string;
  password: string;
  rememberMe?: boolean;
}

interface RefreshDto {
  refreshToken?: string;
}

interface LogoutDto {
  logoutAll?: boolean;
}

@Controller('auth')
export class AuthController {
  constructor(
    @Inject(TOKENS.USER_REPOSITORY)
    private readonly userRepository: UserRepository,
    @Inject(TOKENS.LOGGER)
    private readonly logger: Logger,
    @Inject(TOKENS.I18N_SERVICE)
    private readonly i18n: I18nService,
    @Inject(TOKENS.CONFIG_SERVICE)
    private readonly configService: ConfigService,
    // Service d'authentification (√† cr√©er)
    // @Inject(TOKENS.AUTH_TOKEN_SERVICE)
    // private readonly authTokenService: AuthTokenService,
    // Service de validation des mots de passe (√† cr√©er)
    // @Inject(TOKENS.PASSWORD_SERVICE)
    // private readonly passwordService: IPasswordService,
  ) {}

  /**
   * üîê LOGIN - Authentification avec email/password
   */
  @Post('login')
  @HttpCode(HttpStatus.OK)
  async login(
    @Body() loginDto: LoginDto,
    @Req() request: Request,
    @Res({ passthrough: true }) response: Response,
  ): Promise<LoginResponse> {
    this.logger.info(
      this.i18n.t('auth.login_attempt', { email: loginDto.email }),
      {
        operation: 'AUTH_LOGIN',
        email: loginDto.email,
        rememberMe: loginDto.rememberMe,
        userAgent: request.headers['user-agent'],
        ip: this.extractClientIP(request),
      },
    );

    try {
      // 1. Validation de l'email
      const email = new Email(loginDto.email);

      // 2. Recherche de l'utilisateur
      const user = await this.userRepository.findByEmail(email);
      if (!user) {
        throw new UnauthorizedException(
          this.i18n.t('auth.invalid_credentials'),
        );
      }

      // 3. Validation du mot de passe
      // const isPasswordValid = await this.passwordService.validatePassword(
      //   loginDto.password,
      //   user.passwordHash,
      // );
      // if (!isPasswordValid) {
      //   throw new UnauthorizedException(
      //     this.i18n.t('auth.invalid_credentials'),
      //   );
      // }

      // 4. Cr√©ation du contexte de s√©curit√©
      // const securityContext = this.authTokenService.createSecurityContext(request);

      // 5. G√©n√©ration des tokens
      // const tokens = await this.authTokenService.generateAuthTokens(user, securityContext);

      // 6. Configuration des cookies
      // this.authTokenService.setAuthCookies(response, tokens, securityContext);

      // 7. Cr√©ation de la session (TODO: impl√©menter DeviceSessionRepository)

      const mockTokens = {
        accessToken: 'mock_access_token',
        refreshToken: 'mock_refresh_token',
        expiresIn: 900, // 15 min
        refreshExpiresIn: 604800, // 7 jours
      };

      // üìù Configuration des cookies s√©curis√©s apr√®s login r√©ussi
      this.setAuthCookies(response, mockTokens, loginDto.rememberMe);

      const loginResponse: LoginResponse = {
        user: {
          id: user.id,
          email: user.email.value,
          name: user.name,
          role: user.role,
        },
        tokens: mockTokens,
        session: {
          sessionId: `sess_${Date.now()}`,
          createdAt: new Date().toISOString(),
          expiresAt: new Date(Date.now() + 900 * 1000).toISOString(),
          deviceInfo: {
            userAgent: request.headers['user-agent'],
            ip: this.extractClientIP(request),
          },
        },
      };

      this.logger.info(
        this.i18n.t('auth.login_successful', {
          userId: user.id,
          email: user.email.value,
        }),
        {
          operation: 'AUTH_LOGIN',
          userId: user.id,
          sessionId: loginResponse.session.sessionId,
        },
      );

      return loginResponse;
    } catch (error) {
      this.logger.error(
        this.i18n.t('auth.login_failed', {
          email: loginDto.email,
          error: (error as Error).message,
        }),
        error as Error,
        {
          operation: 'AUTH_LOGIN',
          email: loginDto.email,
        },
      );

      if (error instanceof UnauthorizedException) {
        throw error;
      }

      throw new BadRequestException(this.i18n.t('auth.login_error'));
    }
  }

  /**
   * üîÑ REFRESH TOKEN - Renouvellement de l'access token
   */
  @Post('refresh')
  @HttpCode(HttpStatus.OK)
  async refresh(
    @Body() refreshDto: RefreshDto,
    @Req() request: Request,
    @Res({ passthrough: true }) response: Response,
  ): Promise<RefreshTokenResponse> {
    this.logger.info(this.i18n.t('auth.refresh_attempt'), {
      operation: 'AUTH_REFRESH',
      userAgent: request.headers['user-agent'],
      ip: this.extractClientIP(request),
    });

    try {
      // 1. Extraction du refresh token (cookie ou body)
      // const refreshToken = refreshDto.refreshToken ||
      //   this.authTokenService.extractTokenFromRequest(request, 'refresh');

      // if (!refreshToken) {
      //   throw new UnauthorizedException(
      //     this.i18n.t('auth.refresh_token_missing'),
      //   );
      // }

      // 2. Validation du refresh token
      // const payload = await this.authTokenService.validateToken(refreshToken, 'refresh');
      // if (!payload) {
      //   throw new UnauthorizedException(
      //     this.i18n.t('auth.invalid_refresh_token'),
      //   );
      // }

      // 3. R√©cup√©ration de l'utilisateur
      // const user = await this.userRepository.findById(payload.sub);
      // if (!user) {
      //   throw new UnauthorizedException(
      //     this.i18n.t('auth.user_not_found'),
      //   );
      // }

      // 4. G√©n√©ration du nouvel access token
      // const securityContext = this.authTokenService.createSecurityContext(request);
      // const result = await this.authTokenService.refreshAccessToken(
      //   refreshToken,
      //   user,
      //   securityContext,
      // );

      // 5. Configuration du cookie access token
      // response.cookie('auth_access_token', result.accessToken, {
      //   httpOnly: true,
      //   secure: process.env.NODE_ENV === 'production',
      //   sameSite: 'strict',
      //   maxAge: result.expiresIn * 1000,
      // });

      // Mock pour le d√©veloppement
      const mockResponse: RefreshTokenResponse = {
        accessToken: 'mock_new_access_token',
        expiresIn: 900,
        user: {
          id: 'mock_user_id',
          email: 'mock@example.com',
          name: 'Mock User',
          role: 'USER',
        },
      };

      // üìù Mise √† jour du cookie access token uniquement
      const isProduction = process.env.NODE_ENV === 'production';
      response.cookie('auth_access_token', mockResponse.accessToken, {
        httpOnly: true,
        secure: isProduction,
        sameSite: isProduction ? 'strict' : 'lax',
        domain: isProduction ? process.env.COOKIE_DOMAIN : undefined,
        path: '/',
        maxAge: mockResponse.expiresIn * 1000, // 15 minutes
      });

      this.logger.info(this.i18n.t('auth.refresh_successful'), {
        operation: 'AUTH_REFRESH',
        userId: mockResponse.user.id,
      });

      return mockResponse;
    } catch (error) {
      this.logger.error(
        this.i18n.t('auth.refresh_failed', {
          error: (error as Error).message,
        }),
        error as Error,
        {
          operation: 'AUTH_REFRESH',
        },
      );

      throw new UnauthorizedException(this.i18n.t('auth.refresh_error'));
    }
  }

  /**
   * üö™ LOGOUT - D√©connexion avec suppression des cookies
   */
  @Post('logout')
  @HttpCode(HttpStatus.OK)
  async logout(
    @Body() logoutDto: LogoutDto,
    @Req() request: Request,
    @Res({ passthrough: true }) response: Response,
  ): Promise<{ message: string }> {
    this.logger.info(this.i18n.t('auth.logout_attempt'), {
      operation: 'AUTH_LOGOUT',
      logoutAll: logoutDto.logoutAll,
      userAgent: request.headers['user-agent'],
      ip: this.extractClientIP(request),
    });

    try {
      // 1. Extraction du refresh token
      // const refreshToken = this.authTokenService.extractTokenFromRequest(request, 'refresh');

      // 2. R√©vocation des tokens en base de donn√©es
      // if (refreshToken) {
      //   await this.deviceSessionRepository.revokeByRefreshToken(refreshToken);
      // }

      // 3. Logout de tous les appareils si demand√©
      // if (logoutDto.logoutAll && refreshToken) {
      //   const payload = await this.authTokenService.validateToken(refreshToken, 'refresh');
      //   if (payload) {
      //     await this.deviceSessionRepository.revokeAllByUserId(payload.sub);
      //   }
      // }

      // 4. Suppression des cookies
      // const securityContext = this.authTokenService.createSecurityContext(request);
      // this.authTokenService.clearAuthCookies(response, securityContext);

      // üìù Suppression s√©curis√©e des cookies d'authentification
      this.clearAuthCookies(response);

      this.logger.info(this.i18n.t('auth.logout_successful'), {
        operation: 'AUTH_LOGOUT',
        logoutAll: logoutDto.logoutAll,
      });

      return {
        message: this.i18n.t('auth.logout_success'),
      };
    } catch (error) {
      this.logger.error(
        this.i18n.t('auth.logout_failed', {
          error: (error as Error).message,
        }),
        error as Error,
        {
          operation: 'AUTH_LOGOUT',
        },
      );

      throw new BadRequestException(this.i18n.t('auth.logout_error'));
    }
  }

  /**
   * üë§ ME - Informations sur l'utilisateur connect√©
   */
  @Get('me')
  async getCurrentUser(
    @Req() request: Request,
  ): Promise<{ user: LoginResponse['user'] }> {
    this.logger.info(this.i18n.t('auth.me_attempt'), {
      operation: 'AUTH_ME',
      userAgent: request.headers['user-agent'],
      ip: this.extractClientIP(request),
    });

    try {
      // 1. Extraction de l'access token
      // const accessToken = this.authTokenService.extractTokenFromRequest(request, 'access');
      // if (!accessToken) {
      //   throw new UnauthorizedException(
      //     this.i18n.t('auth.access_token_missing'),
      //   );
      // }

      // 2. Validation du token
      // const payload = await this.authTokenService.validateToken(accessToken, 'access');
      // if (!payload) {
      //   throw new UnauthorizedException(
      //     this.i18n.t('auth.invalid_access_token'),
      //   );
      // }

      // 3. R√©cup√©ration des informations utilisateur
      // const user = await this.userRepository.findById(payload.sub);
      // if (!user) {
      //   throw new UnauthorizedException(
      //     this.i18n.t('auth.user_not_found'),
      //   );
      // }

      // Mock pour le d√©veloppement
      const mockUser = {
        user: {
          id: 'mock_user_id',
          email: 'mock@example.com',
          name: 'Mock User',
          role: 'USER',
        },
      };

      this.logger.info(this.i18n.t('auth.me_successful'), {
        operation: 'AUTH_ME',
        userId: mockUser.user.id,
      });

      return mockUser;
    } catch (error) {
      this.logger.error(
        this.i18n.t('auth.me_failed', {
          error: (error as Error).message,
        }),
        error as Error,
        {
          operation: 'AUTH_ME',
        },
      );

      throw new UnauthorizedException(
        this.i18n.t('auth.authentication_required'),
      );
    }
  }

  /**
   * ÔøΩ Configuration des cookies d'authentification
   */
  private setAuthCookies(
    response: Response,
    tokens: { accessToken: string; refreshToken: string },
    rememberMe?: boolean,
  ): void {
    // D√©tection de l'environnement
    const isProduction = process.env.NODE_ENV === 'production';
    
    // Configuration des cookies selon l'environnement
    const cookieOptions = {
      httpOnly: true,
      secure: isProduction, // HTTPS uniquement en production
      sameSite: (isProduction ? 'strict' : 'lax') as 'strict' | 'lax',
      domain: isProduction ? process.env.COOKIE_DOMAIN : undefined,
      path: '/',
    };

    // Cookie pour access token (dur√©e courte : 15 minutes)
    response.cookie('auth_access_token', tokens.accessToken, {
      ...cookieOptions,
      maxAge: 15 * 60 * 1000, // 15 minutes en millisecondes
    });

    // Cookie pour refresh token (dur√©e adaptative selon rememberMe)
    const refreshMaxAge = rememberMe 
      ? 7 * 24 * 60 * 60 * 1000  // 7 jours si "Se souvenir de moi"
      : 24 * 60 * 60 * 1000;     // 1 jour sinon

    response.cookie('auth_refresh_token', tokens.refreshToken, {
      ...cookieOptions,
      maxAge: refreshMaxAge,
    });

    this.logger.debug('Auth cookies configured', {
      operation: 'SET_AUTH_COOKIES',
      hasAccessToken: !!tokens.accessToken,
      hasRefreshToken: !!tokens.refreshToken,
      rememberMe,
      isProduction,
    });
  }

  /**
   * üßπ Suppression des cookies d'authentification
   */
  private clearAuthCookies(response: Response): void {
    const isProduction = process.env.NODE_ENV === 'production';
    
    const cookieOptions = {
      httpOnly: true,
      secure: isProduction,
      sameSite: (isProduction ? 'strict' : 'lax') as 'strict' | 'lax',
      domain: isProduction ? process.env.COOKIE_DOMAIN : undefined,
      path: '/',
    };

    response.clearCookie('auth_access_token', cookieOptions);
    response.clearCookie('auth_refresh_token', cookieOptions);

    this.logger.debug('Auth cookies cleared', {
      operation: 'CLEAR_AUTH_COOKIES',
      isProduction,
    });
  }

  /**
   * ÔøΩüåê Extrait l'IP client r√©elle
   */
  private extractClientIP(request: Request): string {
    return (
      (request.headers['cf-connecting-ip'] as string) ||
      (request.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() ||
      (request.headers['x-real-ip'] as string) ||
      request.connection.remoteAddress ||
      request.socket.remoteAddress ||
      'unknown'
    );
  }
}
